<?php
// $Id$

/**
 *  @file
 *  The Game Clock module will increment the turn on a game clock,
 *  and handle multiple clocks, with different incrementation rates.
 *  It will activate cron to see whether it's time to increment the turn.
 *  It will also optionally check on page loads, useful for fast turns on busy
 *  sites.
 */

/**
 *  Implements hook_help().
 */
function game_clock_help($section) {
  switch ($section) {
    case 'admin/settings/game_clock':
      return t("
        <p>Game clocks may be used for various purposes, such as keeping an in-game calendar, tracking game effects and events, and limiting characters to acting at a slower pace suitable for a web-based game.</p>
        <p>You may view all active game clocks from this page, as well as create new clocks below. Additionally, you can create new game clocks programmatically with the API provided with the Game Clock module. See the !help page for more information.</p>
", array('!help' => l(t('Game Clock help'), 'admin/help/game_clock')));
    case 'admin/help#game_clock':
      module_load_include('inc', 'game_clock', 'includes/game_clock.help');
      return _game_clock_help($section);
  }
}

/**
 *  Pause or start a game clock.
 *  @param $clock
 *    The name of the game clock to pause or start.
 *  @param $status
 *    If FALSE, then pause the clock, and invoke all
 *    hook_game_clock('pause', $game, $state). If TRUE, then start the clock,
 *    invoke all hook_game_clock('start', $game, $state), and increment the
 *    clock if needed.
 */
function game_clock_pause($clock = 'default', $status = FALSE) {
  $state = game_clock_state($clock);
  if ($state->status != $status) {
    global $game_clocks;
    $game_clocks[$clock]->status = $status;
    db_query('UPDATE {game_clocks} SET status = %d WHERE cid = %d', $status, $state->cid);
    module_invoke_all('game_clock', ($status ? 'start' : 'pause'), $clock, $game_clocks[$clock]);
    game_clock_increment($clock);
  }
}

/**
 *  Start a game clock.
 *  @param $clock
 *    The game clock to start. This calls game_clock_pause, which will in
 *    effect invoke all hook_game_clock('start', $clock, $state) and increment
 *    the clock if needed.
 */
function game_clock_start($clock = 'default') {
  game_clock_pause($clock, TRUE);
}

/**
 *  This will check to see if the clock needs to be incremented, and increment
 *  accordingly.
 *  If the clock does need to be incremented, then it will also invoke_all
 *  hook_game_clock('increment', $clock, $state) functions.
 *  If the game is paused, it will not increment, even if forced.
 *  @param $clock
 *    The game clock to check and increment accordingly.
 *  @param $force
 *    If TRUE, then force the clock to increment, regardless of whether it's
 *    time yet (assuming the clock isn't paused).
 *  @return
 *    Returns the number of ticks the clock incremented, or 0 if it wasn't
 *    incremented.
 */
function game_clock_increment($clock = 'default', $force = FALSE) {
  $state = game_clock_state($clock);
  // If the clock is paused or doesn't exist, then return.
  if (!$state->status) {
    return 0;
  }

  // If it's time for the next tick, or if we're manually incrementing the clock, then increment.
  if (($state->increment && (time() >= ($state->next_tick))) || $force) {
    global $game_clocks;

    // If the clock has run in the past, then figure out how many turns we've missed.
    // This ensures the clock represents the correct tick.
    $game_clocks[$clock]->ticks = ($game_clocks[$clock]->next_tick ? floor((time() - $game_clocks[$clock]->next_tick) / $game_clocks[$clock]->increment) : 0) + 1;

    // Increment the clock by the number of turns missed, plus 1 for the next turn.
    $game_clocks[$clock]->turn += $game_clocks[$clock]->ticks;

    if ($game_clocks[$clock]->increment) {
      // Record the next turn that we should increment the clock.
      $game_clocks[$clock]->next_tick = time() + $game_clocks[$clock]->increment;
    }

    // Store the clock state to the database. Note that we don't store the ->ticks,
    // but they'll be passed to the modules in the next step.
    db_query("UPDATE {game_clocks} SET turn = %d, next_tick = %d WHERE cid = %d", $game_clocks[$clock]->turn, $game_clocks[$clock]->next_tick, $game_clocks[$clock]->cid);

    // Invoke hook_game_clock('increment'). Note that we pass ->ticks, so the modules know how many
    // ticks have actually passed, rather than necessarily incrementing for every tick.
    module_invoke_all('game_clock', 'increment', $clock, $game_clocks[$clock]);

    // The clock incremented. Return the number of ticks incremented.
    return $game_clocks[$clock]->ticks;
  }

  // The clock was not incremented.
  return 0;
}

/**
 *  Reset the turns in a game clock.
 *  This will invoke_all hook_game_clock('reset', $clock, $state).
 *  @param $clock
 *    The game clock to reset.
 *  @param $turn
 *    If provided, then reset the game clock to this turn. Otherwise, set it
 *    back to 0.
 */
function game_clock_reset($clock = 'default', $turn = NULL) {
  global $game_clocks;
  $state = game_clock_state($clock);
  $game_clocks[$clock]->turn = isset($turn) ? $turn : 0;
  $game_clocks[$clock]->next_tick = 0;
  db_query("UPDATE {game_clocks} SET turn = %d, next_tick = %d WHERE cid = %d", $game_clocks[$clock]->turn, $game_clocks[$clock]->next_tick, $game_clocks[$clock]->cid);
  module_invoke_all('game_clock', 'reset', $clock, $game_clocks[$clock]);
  game_clock_increment($clock);
}

/**
 *  Create a new game clock.
 *  @param $state
 *    An object or array with at least the following neccessary parameters:
 *    ['name'] => A unique machine name.
 *    ['title'] => A human readable name for the clock.
 *    ['increment'] => The number of seconds before incrementing each tick.
 *    hook_game_clock('create', $state->name, $state); will be invoked if
 *    successful.
 *  @param $report_errors
 *    If TRUE, then display messages of any errors. In any case, errors will be
 *    logged to the watchdog.
 *  @return
 *    Either the newly created clock object, or FALSE if there was an error.
 */
function game_clock_create($state, $report_errors = FALSE) {
  module_load_include('inc', 'game_clock', 'includes/game_clock');
  return _game_clock_create($state, $report_errors);
}

/**
 *  Delete a game clock.
 *  This will also invoke hook_game_clock('delete', $state->name, $state),
 *  after it's been deleted from the database and wiped from the global
 *  variable.
 *  @param $clock
 *    The string of the clock.
 *  @param $report_errors
 *    If TRUE, then display messages of any errors. In any case, errors will be
 *    logged to the watchdog.
 *  @return
 *    TRUE if succeeded; otherwise, FALSE.
 */
function game_clock_delete($clock, $report_errors = FALSE) {
  module_load_include('inc', 'game_clock', 'includes/game_clock');
  return _game_clock_delete($clock, $report_errors);
}

/**
 *  Saves a game clock state.
 *  This assumes the game clock has already been created, and is being edited.
 *  This will also invoke hook_game_clock('save', $state->name, $state).
 *  @param $state
 *    The game clock state to save.
 *  @param $report_errors
 *    If TRUE, then display messages of any errors. In any case, errors will be
 *    logged to the watchdog.
 *  @return
 *    The new state if succeeded; otherwise, FALSE.
 */
function game_clock_save($state, $report_errors = FALSE) {
  module_load_include('inc', 'game_clock', 'includes/game_clock');
  return _game_clock_save($state, $report_errors);
}

/**
 *  Return a game clock state array.
 *  If the state is empty, a new one will be built.
 *  @param $clock
 *    The game clock state to return, as a string. If NULL, then all game
 *    clocks will be reloaded.
 *  @param $is_cid
 *    If TRUE, then $clock is the integer value of the clock's CID, rather than
 *    its ->name.
 *  @return
 *    If $clock is NULL, then return all game clock states. Otherwise, just the
 *    state asked for.
 */
function game_clock_state($clock = NULL, $is_cid = FALSE) {
  global $game_clocks;

  if (is_null($game_clocks)) {
    $game_clocks = array();
  }
  if (is_null($clock)) {
    $game_clocks = array();
    $results = db_query('SELECT * FROM {game_clocks}');
    while ($result = db_fetch_object($results)) {
      $game_clocks[$result->name] = $result;
    }
    return $game_clocks;
  }

  if ($is_cid) {
    foreach ($game_clocks as $name => $state) {
      if ($state->cid == $clock) {
        return $state;
      }
    }
    $results = db_query("SELECT * FROM {game_clocks} WHERE cid = %d", $clock);
    while ($result = db_fetch_object($results)) {
      $game_clocks[$result->name] = $result;
    }
    if ($result) {
      return $game_clocks[$result->name];
    }
    else {
      return;
    }
  }

  if (is_null($game_clocks[$clock])) {
    $results = db_query('SELECT * FROM {game_clocks} WHERE name = "%s"', $clock);
    while ($result = db_fetch_object($results)) {
      $game_clocks[$result->name] = $result;
    }
  }

  return $game_clocks[$clock];
}

/**
 *  Implements hook_init().
 */
function game_clock_init() {
  global $game_clocks;
  $sql = "SELECT * FROM {game_clocks} WHERE status <> 0 AND increment > 0 AND init <> 0 AND next_tick < %d ORDER BY next_tick";
  if ($limit = variable_get('game_clock_limit_on_init', 0)) {
    $results = db_query_range($sql, 0, $limit);
  }
  else {
    $results = db_query($sql, time());
  }
  while ($result = db_fetch_object($results)) {
    $game_clocks[$result->name] = $result;
    game_clock_increment($result->name);
  }
}

/**
 *  Implements hook_cron().
 */
function game_clock_cron() {
  global $game_clocks;
  $sql = "SELECT * FROM {game_clocks} WHERE status <> 0 AND increment > 0 AND next_tick < %d ORDER BY next_tick";
  if ($limit = variable_get('game_clock_limit_on_cron', 0)) {
    $results = db_query_range($sql, 0, $limit);
  }
  else {
    $results = db_query($sql, time());
  }
  while ($result = db_fetch_object($results)) {
    $game_clocks[$result->name] = $result;
    game_clock_increment($result->name);
  }
}

/**
 *  Implements hook_menu().
 */
function game_clock_menu() {
  module_load_include('inc', 'game_clock', 'includes/game_clock.menu');
  return _game_clock_menu();
}

/**
 *  Implement hook_load() (for menu, not for node).
 *  Helper function for menu: this loads the %game_clock argument.
 */
function game_clock_load($clock) {
  return game_clock_state($clock);
}

/**
 *  Implements hook_perm().
 */
function game_clock_perm() {
  return array('administer game clock');
}

/**
 *  Implements hook_block().
 */
function game_clock_block($op = 'list', $delta = 'default', $edit = array()) {
  switch ($op) {
    case 'list':
      $blocks = array();
      foreach (game_clock_state() as $game => $state) {
        // Only make a block available if it's been checked on the game clock administration page.
        if ($state->block) {
          $blocks[$game] = array(
            'info' => t('Game clock: @title', array('@title' => $state->title)),
          );
        }
      }
      return $blocks;
    case 'view':
      $state = game_clock_state($delta);
      if ($state->cid) {
        $block = array(
          'subject' => t('@title', array('@title' => $state->title)),
          'content' => theme('game_clock_block', $delta),
        );
      }
      return $block;
  }
}

/**
 *  Implements hook_theme().
 */
function game_clock_theme($existing, $type, $theme, $path) {
  return array(
    'game_clock_block' => array(
      'arguments' => array('clock' => 'default'),
      'file' => 'includes/game_clock.theme.inc',
    ),
    'game_clock_settings_form' => array(
      'arguments' => array('form' => NULL),
      'file' => 'includes/game_clock.admin.inc',
    ),
  );
}

