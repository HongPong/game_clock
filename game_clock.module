<?php

/**
 *  @file
 *  The Game Clock module will increment the turn on a game clock,
 *  and handle multiple clocks, with different incrementation rates.
 *  It will activate cron to see whether it's time to increment the turn.
 *  It will also optionally check on page loads, useful for fast turns on busy
 *  sites.
 */

/**
 * Implements hook_help().
 */
function game_clock_help($section) {
  switch ($section) {
    case 'admin/config/game_clock':
      return t("
        <p>Game clocks may be used for various purposes, such as keeping an in-game calendar, tracking game effects and events, and limiting characters to acting at a slower pace suitable for a web-based game.</p>
        <p>You may view all active game clocks from this page, as well as create new clocks below. Additionally, you can create new game clocks programmatically with the API provided with the Game Clock module. See the !help page for more information.</p>
", array('!help' => l(t('Game Clock help'), 'admin/help/game_clock')));
    case 'admin/help#game_clock':
      module_load_include('inc', 'game_clock', 'includes/game_clock.help');
      return _game_clock_help($section);
  }
}

/**
 *  Pause or start a game clock.
 *  @param $clock
 *    The name of the game clock to pause or start.
 *  @param $status
 *    If FALSE, then pause the clock, and invoke all
 *    hook_game_clock_pause($game, $state).
 *    If TRUE, then start the clock, invoke all
 *    hook_game_clock_start($game, $state),
 *    and increment the clock if needed.
 */
function game_clock_pause($clock = 'default', $status = FALSE) {
  drupal_set_message('40 game_clock_pausse CALLED ');
  $state = game_clock_state($clock);
  if ($state->status != $status) {
    global $game_clocks;
    $game_clocks[$clock]->status = $status;
    // TODO Please review the conversion of this statement to the D7 database API syntax.
    /* db_query('UPDATE {game_clocks} SET status = %d WHERE cid = %d', $status, $state->cid) */
    db_update('game_clocks')
  ->fields(array(
      'status' => $status,
    ))
  ->condition('cid', $state->cid)
  ->execute();
    module_invoke_all('game_clock_' . ($status ? 'start' : 'pause'), $clock, $game_clocks[$clock]);
    game_clock_increment($clock);
  }
}

/**
 *  Start a game clock.
 *  @param $clock
 *    The game clock to start. This calls game_clock_pause, which will in
 *    effect invoke all hook_game_clock('start', $clock, $state) and increment
 *    the clock if needed.
 */
function game_clock_start($clock = 'default') {
  game_clock_pause($clock, TRUE);
}

/**
 *  This will check to see if the clock needs to be incremented, and increment
 *  accordingly.
 *  If the clock does need to be incremented, then it will also invoke_all
 *  hook_game_clock_increment($clock, $state) functions.
 *  If the game is paused, it will not increment, even if forced.
 *  @param $clock
 *    The game clock to check and increment accordingly.
 *  @param $force
 *    If TRUE, then force the clock to increment, regardless of whether it's
 *    time yet (assuming the clock isn't paused).
 *  @return
 *    Returns the number of ticks the clock incremented, or 0 if it wasn't
 *    incremented.
 */
function game_clock_increment($clock = 'default', $force = FALSE) {
  drupal_set_message('85 game_clock_increment CALLED ');
  $state = game_clock_state($clock);
  // If the clock is paused or doesn't exist, then return.
  if (!$state->status) {
    return 0;
  }

  // If it's time for the next tick, or if we're manually incrementing the clock, then increment.
  if (($state->increment && (REQUEST_TIME >= ($state->next_tick))) || $force) {
    global $game_clocks;

    // If the clock has run in the past, then figure out how many turns we've missed.
    // This ensures the clock represents the correct tick.

    // First, get the number of seconds passed since it should have ticked.
    $passed = REQUEST_TIME - $game_clocks[$clock]->next_tick;

    // The number of ticks will equal the number of seconds passed divided by the increment, rounding down and adding one.
    $game_clocks[$clock]->ticks = ($game_clocks[$clock]->next_tick ? floor($passed / $game_clocks[$clock]->increment) : 0) + 1;

    // Increment the clock by the number of turns missed, plus 1 for the next turn.
    $game_clocks[$clock]->turn += $game_clocks[$clock]->ticks;

    if ($game_clocks[$clock]->increment) {
      // Record the next turn that we should increment the clock.
      // Subtract the amount left over from our earlier $passed division for better accuracy.
      $game_clocks[$clock]->next_tick = REQUEST_TIME + $game_clocks[$clock]->increment - fmod($passed, $game_clocks[$clock]->increment);
    }

    // Store the clock state to the database. Note that we don't store the ->ticks,
    // but they'll be passed to the modules in the next step.
    // TODO Please review the conversion of this statement to the D7 database API syntax.
    /* db_query("UPDATE {game_clocks} SET turn = %d, next_tick = %d WHERE cid = %d", $game_clocks[$clock]->turn, $game_clocks[$clock]->next_tick, $game_clocks[$clock]->cid) */
    db_update('game_clocks')
  ->fields(array(
      'turn' => $game_clocks[$clock]->turn,
      'next_tick' => $game_clocks[$clock]->next_tick,
    ))
  ->condition('cid', $game_clocks[$clock]->cid)
  ->execute();

    // Invoke hook_game_clock_increment. Note that we pass ->ticks, so the modules know how many
    // ticks have actually passed, rather than necessarily incrementing for every tick.
    module_invoke_all('game_clock_increment', $clock, $game_clocks[$clock]);

    // The clock incremented. Return the number of ticks incremented.
    return $game_clocks[$clock]->ticks;
  }

  // The clock was not incremented.
  return 0;
}

/**
 *  Reset the turns in a game clock.
 *  This will invoke_all hook_game_clock_reset($clock, $state).
 *  @param $clock
 *    The game clock to reset.
 *  @param $turn
 *    If provided, then reset the game clock to this turn. Otherwise, set it
 *    back to 0.
 */
function game_clock_reset($clock = 'default', $turn = NULL) {
  global $game_clocks;
  drupal_set_message('147 game_clock_reset CALLED ');

  $state = game_clock_state($clock);
  $game_clocks[$clock]->turn = isset($turn) ? $turn : 0;
  $game_clocks[$clock]->next_tick = 0;
  // TODO Please review the conversion of this statement to the D7 database API syntax.
  /* db_query("UPDATE {game_clocks} SET turn = %d, next_tick = %d WHERE cid = %d", $game_clocks[$clock]->turn, $game_clocks[$clock]->next_tick, $game_clocks[$clock]->cid) */
  db_update('game_clocks')
  ->fields(array(
    'turn' => $game_clocks[$clock]->turn,
    'next_tick' => $game_clocks[$clock]->next_tick,
  ))
  ->condition('cid', $game_clocks[$clock]->cid)
  ->execute();
  module_invoke_all('game_clock_reset', $clock, $game_clocks[$clock]);
  game_clock_increment($clock);
}

/**
 *  Create a new game clock.
 *  @param $state
 *    An object or array with at least the following neccessary parameters:
 *    ['name'] => A unique machine name.
 *    ['title'] => A human readable name for the clock.
 *    ['increment'] => The number of seconds before incrementing each tick.
 *    hook_game_clock_create(state->name, $state); will be invoked if
 *    successful.
 *  @param $report_errors
 *    If TRUE, then display messages of any errors. In any case, errors will be
 *    logged to the watchdog.
 *  @return
 *    Either the newly created clock object, or FALSE if there was an error.
 */
function game_clock_create($state, $report_errors = FALSE) {
  module_load_include('inc', 'game_clock', 'includes/game_clock');
  return _game_clock_create($state, $report_errors);
}

/**
 *  Delete a game clock.
 *  This will also invoke hook_game_clock_delete($state->name, $state),
 *  after it's been deleted from the database and wiped from the global
 *  variable.
 *  @param $clock
 *    The string of the clock.
 *  @param $report_errors
 *    If TRUE, then display messages of any errors. In any case, errors will be
 *    logged to the watchdog.
 *  @return
 *    TRUE if succeeded; otherwise, FALSE.
 */
function game_clock_delete($clock, $report_errors = FALSE) {
  module_load_include('inc', 'game_clock', 'includes/game_clock');
  return _game_clock_delete($clock, $report_errors);
}

/**
 *  Saves a game clock state.
 *  This assumes the game clock has already been created, and is being edited.
 *  This will also invoke hook_game_clock_save($state->name, $state).
 *  @param $state
 *    The game clock state to save.
 *  @param $report_errors
 *    If TRUE, then display messages of any errors. In any case, errors will be
 *    logged to the watchdog.
 *  @return
 *    The new state if succeeded; otherwise, FALSE.
 */
function game_clock_save($state, $report_errors = FALSE) {
  module_load_include('inc', 'game_clock', 'includes/game_clock');
  return _game_clock_save($state, $report_errors);
}

/**
 *  Return a game clock state array.
 *  If the state is empty, a new one will be built.
 *  @param $clock
 *    The game clock state to return, as a string. If NULL, then all game
 *    clocks will be reloaded.
 *  @param $is_cid
 *    If TRUE, then $clock is the integer value of the clock's CID, rather than
 *    its ->name.
 *  @return
 *    If $clock is NULL, then return all game clock states. Otherwise, just the
 *    state asked for.
 */
function game_clock_state($clock = NULL, $is_cid = NULL) {
  global $game_clocks;
  drupal_set_message('233 GAMECLOCKSTATE CALLED ');
  drupal_set_message('234 the clock is $clock ' . $clock);
  dpm($game_clocks);
  dpm($clock);
  dpm($is_cid);
  //print_r($clock) ; print('is clock');
  if (!isset($game_clocks)) {
    $game_clocks = array();
  }
  if (!isset($clock)) {
    drupal_set_message('242 no clock at game clock state');
    $game_clocks = array();
    $results = db_query('SELECT * FROM {game_clocks}');
    // TODO needs to be patched database for D7 ^
    //while ($result = db_fetch_object($results)) {
    while ($result = $results->fetchObject()) {
      $game_clocks[$result->name] = $result;
    }
    return $game_clocks;
  }

  // If we've been passed an object, then we'll simply use its cid.
  if (is_object($clock)) {
    drupal_set_message('255 game clock state got $clock object');
    $clock = $clock->cid;
    $is_cid = TRUE;
  }

  // If we don't specify, we try to determine if we were passed a number.
  if (!isset($is_cid)) {
      drupal_set_message('262 game clock state got $clock object w.o cid');
    $is_cid = is_numeric($clock);
  }

  if ($is_cid) {
      drupal_set_message('267 game clock state got $is_cid true');

    foreach ($game_clocks as $name => $state) {
      if ($state->cid == $clock) {
        return $state;
      }
    }
        //$result = db_query("SELECT * FROM {game_clocks} WHERE cid = %d", array($clock))->fetchObject();
        $result = db_query("SELECT * FROM {game_clocks} WHERE cid = :cid", array(':cid' => $clock));
    //WAS $result = db_fetch_object(db_query("SELECT * FROM {game_clocks} WHERE cid = :cid", array(':cid' => $clock)));
    if (isset($result->cid) && $result->cid) {
      $game_clocks[$result->name] = $result;
      return $result;
    }
    return;
  }

 /* if (!isset($game_clocks[$clock])) {
    $results = db_query('SELECT * FROM {game_clocks} WHERE name = :name', array(':name' => $clock));
    while ($result = db_fetch_object($results)) {
      $game_clocks[$result->name] = $result;
    }
  }*/
      drupal_set_message('290 game clock state finally to sql');

    $sql = db_query('SELECT * FROM {game_clocks} WHERE name = :clock_name', array(
   ':clock_name' => $clock));
       drupal_set_message('294 $sql = ' . var_dump($sql));

    // end patch d7 db
    while ($result = db_query($sql)->fetchObject()) {
    //while ($result = db_fetch_object($results)) {
      $game_clocks[$result->name] = $result;
    }
  dpm($game_clocks[$clock]);
      drupal_set_message('302 game clock state lets retunr $game_clocks[$clock]' . $game_clocks);

  return $game_clocks[$clock];
  //TODO Undefined index: testname in game_clock_state() 
}

/**
 *  Returns all clocks of a specified type.
 *  @param $type
 *    (optional, defaults to '') The type of clock to return.
 *  @return
 *    An array of all game clock objects matching the type.
 */
function game_clock_type_states($type = '') {
  drupal_set_message('316 game_clock_type_statuses called');
  global $game_clocks;

  $clocks = array();
  $results = db_query("SELECT * FROM {game_clocks} WHERE type = :type", array(':type' => $type));
  while ($state = db_fetch_object($results)) {
    $game_clocks[$state->name] = $clocks[$state->name] = $state;
  }

  return $clocks;
}

/**
 *  Returns the current turn of the specified game clock.
 *  @param $clock
 *    The clock name or cid.
 *  @return
 *    The current turn of the clock.
 */
function game_clock_current_turn($clock = 'default') {
  $clock = game_clock_load($clock);
  return $clock->turn;
}

/**
 * Implements hook_init().  If game_clock table exists, select each clock where the
 * next tick is greater than the current time.
 */
function game_clock_init() {
  global $game_clocks;
  $tableok = FALSE;
  if (db_table_exists("game_clocks")) {
    $tableok = TRUE;
  }
  else {
    drupal_set_message(t("game_clocks table missing"));
  }
  
  // was $sql = "SELECT * FROM {game_clocks} WHERE status <> 0 AND increment > 0 AND init <> 0 AND next_tick < %d ORDER BY next_tick";
  $sql = "SELECT * FROM {game_clocks} WHERE status <> 0 AND increment > 0 AND init <> 0 AND next_tick < :current_time";

  if ($limit = variable_get('game_clock_limit_on_init', 0)) {
    // TODO Please convert this statement to the D7 database API syntax.
        // This limits how many clocks to process during a single page load.
    // Set it if you have a high volume of game clocks and have pages timing out.
    // starts at record 0, with limit $limit
    $results = db_query_range($sql, 0, $limit);
  }
  else {
    // TODO Please convert this statement to the D7 database API syntax.
      $results = db_query($sql, array(':current_time' => REQUEST_TIME)); // FIXED
  }
  while ($result = $results->fetchObject()) {
    $game_clocks[$result->name] = $result;
    game_clock_increment($result->name);
  }
}

/**
 * Implements hook_cron().
 */
function game_clock_cron() {
  global $game_clocks;
  $sql = "SELECT * FROM {game_clocks} WHERE status <> 0 AND increment > 0 AND next_tick < %d ORDER BY next_tick";
  if ($limit = variable_get('game_clock_limit_on_cron', 0)) {
    // TODO Please convert this statement to the D7 database API syntax.
    $results = db_query_range($sql);
  }
  else {
    // TODO Please convert this statement to the D7 database API syntax.
    $results = db_query($sql, REQUEST_TIME);
  }
  while ($result = db_fetch_object($results)) {
    $game_clocks[$result->name] = $result;
    game_clock_increment($result->name);
  }
}

/**
 * Implements hook_menu().
 */
function game_clock_menu() {
  module_load_include('inc', 'game_clock', 'includes/game_clock.menu');
  return _game_clock_menu();
}

/**
 * Implements hook_load() (for menu, not for node)().
 *  Helper function for menu: this loads the %game_clock argument.
 */
function game_clock_load($clocks, $is_cid = NULL) {
  drupal_set_message('408 game_clock_load CALLED ');
  drupal_set_message('game_clock_load' . $clocks);
  foreach ($clocks as $nid => &$clock) {
    drupal_set_message('411 foreach ($ clocks as $ nid => &$ clock) a Clock State eval ');
    $node_additions = game_clock_state($clock, $is_cid);
    foreach ($node_additions as $property => &$value) {
      $clock->$property = $value;
    }
  }
}

/**
 * Implements hook_permission().
 */
function game_clock_permission() {
  return array(
    'administer game clock' => array(
      'title' => t('administer game clock'),
      'description' => t('TODO Add a description for \'administer game clock\''),
    ),
  );
}

/**
 * Implements hook_block_info().
 */
function game_clock_block_info() {
  drupal_set_message('408 game_clock_block_info CALLED ');
  $blocks = array();
  
  foreach (game_clock_state() as $game => $state) {
    // Only make a block available if it's been checked on the game clock administration page.
    if ($state->block) {
      $blocks[$game] = array(
        'info' => t('Game clock: @title', array('@title' => $state->title)),
      );
    }
  }
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function game_clock_block_view($delta) {
  drupal_set_message('408 game_clock_block_view CALLED ');
  $state = game_clock_state($delta);
  if ($state->cid) {
    $block = array(
      'subject' => t('@title', array('@title' => $state->title)),
      'content' => theme('game_clock_block', array('clock' => $delta)),
    );
  }
  return $block;
}

/**
 * Implements hook_block().
 */
function game_clock_block_OLD($op = 'list', $delta = 'default', $edit = array()) { }

/**
 * Implements hook_theme().
 */
function game_clock_theme($existing, $type, $theme, $path) {
  return array(
    'game_clock_block' => array(
      'variables' => array('clock' => 'default'),
      'file' => 'includes/game_clock.theme.inc',
    ),
    'game_clock_settings_form' => array(
      'render element' => 'form',
      'file' => 'includes/game_clock.admin.inc',
    ),
  );
}

